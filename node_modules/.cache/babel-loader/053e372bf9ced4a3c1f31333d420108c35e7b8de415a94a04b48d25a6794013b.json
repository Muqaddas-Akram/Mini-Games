{"ast":null,"code":"import React, { useState, useEffect } from 'react';\nvar WheelComponent = function WheelComponent(_ref) {\n  var segments = _ref.segments,\n    segColors = _ref.segColors,\n    winningSegment = _ref.winningSegment,\n    onFinished = _ref.onFinished,\n    _ref$primaryColor = _ref.primaryColor,\n    primaryColor = _ref$primaryColor === void 0 ? 'black' : _ref$primaryColor,\n    _ref$contrastColor = _ref.contrastColor,\n    contrastColor = _ref$contrastColor === void 0 ? 'white' : _ref$contrastColor,\n    _ref$buttonText = _ref.buttonText,\n    buttonText = _ref$buttonText === void 0 ? 'Spin' : _ref$buttonText,\n    _ref$isOnlyOnce = _ref.isOnlyOnce,\n    isOnlyOnce = _ref$isOnlyOnce === void 0 ? true : _ref$isOnlyOnce,\n    _ref$size = _ref.size,\n    size = _ref$size === void 0 ? 290 : _ref$size,\n    _ref$upDuration = _ref.upDuration,\n    upDuration = _ref$upDuration === void 0 ? 100 : _ref$upDuration,\n    _ref$downDuration = _ref.downDuration,\n    downDuration = _ref$downDuration === void 0 ? 1000 : _ref$downDuration,\n    _ref$fontFamily = _ref.fontFamily,\n    fontFamily = _ref$fontFamily === void 0 ? 'proxima-nova' : _ref$fontFamily;\n  var currentSegment = '';\n  var isStarted = false;\n  var _useState = useState(false),\n    isFinished = _useState[0],\n    setFinished = _useState[1];\n  var timerHandle = 0;\n  var timerDelay = segments.length;\n  var angleCurrent = 0;\n  var angleDelta = 0;\n  var canvasContext = null;\n  var maxSpeed = Math.PI / (\"\" + segments.length);\n  var upTime = segments.length * upDuration;\n  var downTime = segments.length * downDuration;\n  var spinStart = 0;\n  var frames = 0;\n  var centerX = 300;\n  var centerY = 300;\n  useEffect(function () {\n    wheelInit();\n    setTimeout(function () {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  var wheelInit = function wheelInit() {\n    initCanvas();\n    wheelDraw();\n  };\n  var initCanvas = function initCanvas() {\n    var canvas = document.getElementById('canvas');\n    console.log(navigator);\n    if (navigator.userAgent.indexOf('MSIE') !== -1) {\n      canvas = document.createElement('canvas');\n      canvas.setAttribute('width', 1000);\n      canvas.setAttribute('height', 600);\n      canvas.setAttribute('id', 'canvas');\n      document.getElementById('wheel').appendChild(canvas);\n    }\n    canvas.addEventListener('click', spin, false);\n    canvasContext = canvas.getContext('2d');\n  };\n  var spin = function spin() {\n    isStarted = true;\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n  var onTimerTick = function onTimerTick() {\n    frames++;\n    draw();\n    var duration = new Date().getTime() - spinStart;\n    var progress = 0;\n    var finished = false;\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) {\n      angleCurrent -= Math.PI * 2;\n    }\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n  var wheelDraw = function wheelDraw() {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  var draw = function draw() {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  var drawSegment = function drawSegment(key, lastAngle, angle) {\n    var ctx = canvasContext;\n    var value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = 'bold 1em ' + fontFamily;\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n  var drawWheel = function drawWheel() {\n    var ctx = canvasContext;\n    var lastAngle = angleCurrent;\n    var len = segments.length;\n    var PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n    ctx.font = '1em ' + fontFamily;\n    for (var i = 1; i <= len; i++) {\n      var angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 50, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = 'bold 1em ' + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = 'center';\n    ctx.fillText(buttonText, centerX, centerY + 3);\n    ctx.stroke();\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size, 0, PI2, false);\n    ctx.closePath();\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n  var drawNeedle = function drawNeedle() {\n    var ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fileStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(centerX + 20, centerY - 50);\n    ctx.lineTo(centerX - 20, centerY - 50);\n    ctx.lineTo(centerX, centerY - 70);\n    ctx.closePath();\n    ctx.fill();\n    var change = angleCurrent + Math.PI / 2;\n    var i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillStyle = primaryColor;\n    ctx.font = 'bold 1.5em ' + fontFamily;\n    currentSegment = segments[i];\n    isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50);\n  };\n  var clear = function clear() {\n    var ctx = canvasContext;\n    ctx.clearRect(0, 0, 1000, 800);\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    id: \"wheel\"\n  }, /*#__PURE__*/React.createElement(\"canvas\", {\n    id: \"canvas\",\n    width: \"1000\",\n    height: \"800\",\n    style: {\n      pointerEvents: isFinished && isOnlyOnce ? 'none' : 'auto'\n    }\n  }));\n};\nexport default WheelComponent;","map":{"version":3,"names":["WheelComponent","_ref","segments","segColors","winningSegment","onFinished","_ref$primaryColor","primaryColor","_ref$contrastColor","contrastColor","_ref$buttonText","buttonText","_ref$isOnlyOnce","isOnlyOnce","_ref$size","size","_ref$upDuration","upDuration","_ref$downDuration","downDuration","_ref$fontFamily","fontFamily","currentSegment","isStarted","_useState","useState","isFinished","setFinished","timerHandle","timerDelay","length","angleCurrent","angleDelta","canvasContext","maxSpeed","Math","PI","upTime","downTime","spinStart","frames","centerX","centerY","useEffect","wheelInit","setTimeout","window","scrollTo","initCanvas","wheelDraw","canvas","document","getElementById","console","log","navigator","userAgent","indexOf","createElement","setAttribute","appendChild","addEventListener","spin","getContext","Date","getTime","setInterval","onTimerTick","draw","duration","progress","finished","sin","clearInterval","clear","drawWheel","drawNeedle","drawSegment","key","lastAngle","angle","ctx","value","save","beginPath","moveTo","arc","lineTo","closePath","fillStyle","fill","stroke","translate","rotate","font","fillText","substr","restore","len","PI2","lineWidth","strokeStyle","textBaseline","textAlign","i","fileStyle","change","floor","clearRect","React","id","width","height","style","pointerEvents"],"sources":["C:\\Users\\Muqaddas\\Desktop\\My Code\\mini-games\\mini-games\\node_modules\\react-wheel-of-prizes\\src\\index.js"],"sourcesContent":["import React, { useEffect, useState, useRef } from 'react'\n\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = 'black',\n  contrastColor = 'white',\n  buttonText = 'Spin',\n  isOnlyOnce = true,\n  size = 290,\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = 'proxima-nova'\n}) => {\n  let currentSegment = ''\n  let isStarted = false\n  const [isFinished, setFinished] = useState(false)\n  let timerHandle = 0\n  const timerDelay = segments.length\n  let angleCurrent = 0\n  let angleDelta = 0\n  let canvasContext = null\n  let maxSpeed = Math.PI / `${segments.length}`\n  const upTime = segments.length * upDuration\n  const downTime = segments.length * downDuration\n  let spinStart = 0\n  let frames = 0\n  const centerX = 300\n  const centerY = 300\n  useEffect(() => {\n    wheelInit()\n    setTimeout(() => {\n      window.scrollTo(0, 1)\n    }, 0)\n  }, [])\n  const wheelInit = () => {\n    initCanvas()\n    wheelDraw()\n  }\n\n  const initCanvas = () => {\n    let canvas = document.getElementById('canvas')\n    console.log(navigator)\n    if (navigator.userAgent.indexOf('MSIE') !== -1) {\n      canvas = document.createElement('canvas')\n      canvas.setAttribute('width', 1000)\n      canvas.setAttribute('height', 600)\n      canvas.setAttribute('id', 'canvas')\n      document.getElementById('wheel').appendChild(canvas)\n    }\n    canvas.addEventListener('click', spin, false)\n    canvasContext = canvas.getContext('2d')\n  }\n  const spin = () => {\n    isStarted = true\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime()\n      // maxSpeed = Math.PI / ((segments.length*2) + Math.random())\n      maxSpeed = Math.PI / segments.length\n      frames = 0\n      timerHandle = setInterval(onTimerTick, timerDelay)\n    }\n  }\n  const onTimerTick = () => {\n    frames++\n    draw()\n    const duration = new Date().getTime() - spinStart\n    let progress = 0\n    let finished = false\n    if (duration < upTime) {\n      progress = duration / upTime\n      angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2)\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n          progress = 1\n        } else {\n          progress = duration / downTime\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n        }\n      } else {\n        progress = duration / downTime\n        angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n      }\n      if (progress >= 1) finished = true\n    }\n\n    angleCurrent += angleDelta\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2\n    if (finished) {\n      setFinished(true)\n      onFinished(currentSegment)\n      clearInterval(timerHandle)\n      timerHandle = 0\n      angleDelta = 0\n    }\n  }\n\n  const wheelDraw = () => {\n    clear()\n    drawWheel()\n    drawNeedle()\n  }\n\n  const draw = () => {\n    clear()\n    drawWheel()\n    drawNeedle()\n  }\n\n  const drawSegment = (key, lastAngle, angle) => {\n    const ctx = canvasContext\n    const value = segments[key]\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(centerX, centerY)\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false)\n    ctx.lineTo(centerX, centerY)\n    ctx.closePath()\n    ctx.fillStyle = segColors[key]\n    ctx.fill()\n    ctx.stroke()\n    ctx.save()\n    ctx.translate(centerX, centerY)\n    ctx.rotate((lastAngle + angle) / 2)\n    ctx.fillStyle = contrastColor\n    ctx.font = 'bold 1em ' + fontFamily\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0)\n    ctx.restore()\n  }\n\n  const drawWheel = () => {\n    const ctx = canvasContext\n    let lastAngle = angleCurrent\n    const len = segments.length\n    const PI2 = Math.PI * 2\n    ctx.lineWidth = 1\n    ctx.strokeStyle = primaryColor\n    ctx.textBaseline = 'middle'\n    ctx.textAlign = 'center'\n    ctx.font = '1em ' + fontFamily\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent\n      drawSegment(i - 1, lastAngle, angle)\n      lastAngle = angle\n    }\n\n    // Draw a center circle\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, 50, 0, PI2, false)\n    ctx.closePath()\n    ctx.fillStyle = primaryColor\n    ctx.lineWidth = 10\n    ctx.strokeStyle = contrastColor\n    ctx.fill()\n    ctx.font = 'bold 1em ' + fontFamily\n    ctx.fillStyle = contrastColor\n    ctx.textAlign = 'center'\n    ctx.fillText(buttonText, centerX, centerY + 3)\n    ctx.stroke()\n\n    // Draw outer circle\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, size, 0, PI2, false)\n    ctx.closePath()\n\n    ctx.lineWidth = 10\n    ctx.strokeStyle = primaryColor\n    ctx.stroke()\n  }\n\n  const drawNeedle = () => {\n    const ctx = canvasContext\n    ctx.lineWidth = 1\n    ctx.strokeStyle = contrastColor\n    ctx.fileStyle = contrastColor\n    ctx.beginPath()\n    ctx.moveTo(centerX + 20, centerY - 50)\n    ctx.lineTo(centerX - 20, centerY - 50)\n    ctx.lineTo(centerX, centerY - 70)\n    ctx.closePath()\n    ctx.fill()\n    const change = angleCurrent + Math.PI / 2\n    let i =\n      segments.length -\n      Math.floor((change / (Math.PI * 2)) * segments.length) -\n      1\n    if (i < 0) i = i + segments.length\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.fillStyle = primaryColor\n    ctx.font = 'bold 1.5em ' + fontFamily\n    currentSegment = segments[i]\n    isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50)\n  }\n  const clear = () => {\n    const ctx = canvasContext\n    ctx.clearRect(0, 0, 1000, 800)\n  }\n  return (\n    <div id='wheel'>\n      <canvas\n        id='canvas'\n        width='1000'\n        height='800'\n        style={{\n          pointerEvents: isFinished && isOnlyOnce ? 'none' : 'auto'\n        }}\n      />\n    </div>\n  )\n}\nexport default WheelComponent\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}